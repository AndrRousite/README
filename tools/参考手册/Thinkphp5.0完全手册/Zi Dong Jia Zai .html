<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-CN" xml:lang="zh-CN">
  <head>
    <title>自动加载</title>
    <meta content="IE=edge" http-equiv="X-UA-Compatible"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
        <h1 class="book-title" id="calibre_toc_13">自动加载</h1>
<div class="book-content">
    <h2 id="%E6%A6%82%E8%BF%B0" class="calibre15">概述</h2>
<p class="calibre10"><code class="calibre7">ThinkPHP5.0</code>真正实现了按需加载，所有类库采用自动加载机制，并且支持类库映射和<code class="calibre7">composer</code>类库的自动加载。</p>
<p class="calibre10">自动加载的实现由<code class="calibre7">think\Loader</code>类库完成，自动加载规范符合PHP的<code class="calibre7">PSR-4</code>。</p>
<h2 id="%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD" class="calibre15">自动加载</h2>
<p class="calibre10">由于新版<code class="calibre7">ThinkPHP</code>完全采用了命名空间的特性，因此只需要给类库正确定义所在的命名空间，而命名空间的路径与类库文件的目录一致，那么就可以实现类的自动加载。</p>
<p class="calibre10">类库的自动加载检测顺序如下：</p>
<p class="calibre10">1、类库映射检测；<br class="calibre16"/>
2、<code class="calibre7">PSR-4</code>自动加载检测；<br class="calibre16"/>
3、<code class="calibre7">PSR-0</code>自动加载检测；</p>
<p class="calibre10">系统会按顺序检测，一旦检测生效的话，就会自动载入对应的类库文件。</p>
<h2 id="%E7%B1%BB%E5%BA%93%E6%98%A0%E5%B0%84" class="calibre15">类库映射</h2>
<p class="calibre10">遵循我们上面的命名空间定义规范的话，基本上可以完成类库的自动加载了，但是如果定义了较多的命名空间的话，效率会有所下降，所以，我们可以给常用的类库定义类库映射。命名类库映射相当于给类文件定义了一个别名，效率会比命名空间定位更高效，例如：</p>
<pre class="calibre21"><code class="calibre22">Loader::addClassMap('think\Log',LIB_PATH.'think\Log.php');
Loader::addClassMap('org\util\Array',LIB_PATH.'org\util\Array.php');</code></pre>
<p class="calibre10">也可以利用<code class="calibre7">addClassMap</code>方法批量导入类库映射定义，例如：</p>
<pre class="calibre21"><code class="calibre22">$map = [
    'think\Log'     =&gt;  LIB_PATH.'think\Log.php',
    'org\util\array'=&gt;  LIB_PATH.'org\util\Array.php'
];
Loader::addClassMap($map);</code></pre>
<blockquote class="calibre5">
<p class="calibre14">虽然通过类库映射的方式注册的类可以不强制要求对应命名空间目录，但是仍然建议遵循PSR-4规范定义类库和目录。</p>
</blockquote>
<h2 id="%E7%B1%BB%E5%BA%93%E5%AF%BC%E5%85%A5" class="calibre15">类库导入</h2>
<p class="calibre10">如果你不需要系统的自动加载功能，又或者没有使用命名空间的话，那么也可以使用<code class="calibre7">think\Loader</code>类的<code class="calibre7">import</code>方法手动加载类库文件，例如：</p>
<pre class="calibre21"><code class="calibre22">Loader::import('org.util.array');
Loader::import('@.util.upload');</code></pre>
<p class="calibre10">示例</p>
<pre class="calibre21"><code class="calibre22">// 引入 extend/qrcode.php
Loader::import('qrcode', EXTEND_PATH);
// 助手函数
import('qrcode', EXTEND_PATH);

// 引入 extend/wechat-sdk/wechat.class.php
Loader::import('wechat-sdk.wechat', EXTEND_PATH, '.class.php');
// 助手函数
import('wechat-sdk.wechat', EXTEND_PATH, '.class.php');</code></pre>
<table class="calibre25"><thead class="calibre26"><tr class="calibre27"><th class="calibre28">类库导入也采用类似命名空间的概念（但不需要实际的命名空间支持），支持的“根命名空间”包括：</th>
<th class="calibre28">目录</th>
<th class="calibre28">说明</th>
</tr></thead><tbody class="calibre29"><tr class="calibre27"><td class="pcalibre1 calibre30">behavior</td>
<td class="calibre32 pcalibre1">系统行为类库</td>
</tr><tr class="calibre27"><td class="pcalibre1 calibre31">think</td>
<td class="pcalibre1 calibre31">核心基类库</td>
</tr><tr class="calibre27"><td class="pcalibre1 calibre31">traits</td>
<td class="pcalibre1 calibre31">系统Traits类库</td>
</tr><tr class="calibre27"><td class="pcalibre1 calibre31">app</td>
<td class="pcalibre1 calibre31">应用类库</td>
</tr><tr class="calibre27"><td class="pcalibre1 calibre31">@</td>
<td class="calibre33 pcalibre1">表示当前模块类库包</td>
</tr></tbody></table><pre class="calibre21"><code class="calibre22">
如果完全遵从系统的命名空间定义的话，一般来说无需手动加载类库文件，直接实例化即可。

`ThinkPHP5.0`不推荐使用`import`方法。

## Composer自动加载
5.0版本支持`Composer`安装的类库的自动加载，你可以直接按照`Composer`依赖库中的命名空间直接调用。</code></pre>
</div>
	
</body></html>
