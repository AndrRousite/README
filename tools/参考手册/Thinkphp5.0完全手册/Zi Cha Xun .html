<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-CN" xml:lang="zh-CN">
  <head>
    <title>子查询</title>
    <meta content="IE=edge" http-equiv="X-UA-Compatible"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
        <h1 class="book-title" id="calibre_toc_83">子查询</h1>
<div class="book-content">
    <p class="calibre10">首先构造子查询SQL，可以使用下面三种的方式来构建子查询。</p>
<h2 id="1%E3%80%81%E4%BD%BF%E7%94%A8%60select%60%E6%96%B9%E6%B3%95" class="calibre15">1、使用<code class="calibre7">select</code>方法</h2>
<p class="calibre10">当select方法的参数为false的时候，表示不进行查询只是返回构建SQL，例如：</p>
<pre class="calibre21"><code class="calibre22">$subQuery = Db::table('think_user')
    -&gt;field('id,name')
    -&gt;where('id','&gt;',10)
    -&gt;select(false); </code></pre>
<p class="calibre10">生成的subQuery结果为：</p>
<pre class="calibre21"><code class="calibre22">SELECT `id`,`name` FROM `think_user` WHERE `id` &gt; 10 </code></pre>
<h2 id="2%E3%80%81%E4%BD%BF%E7%94%A8%60fetchsql%60%E6%96%B9%E6%B3%95" class="calibre15">2、使用<code class="calibre7">fetchSql</code>方法</h2>
<p class="calibre10">fetchSql方法表示不进行查询而只是返回构建的SQL语句，并且不仅仅支持select，而是支持所有的CURD查询。</p>
<pre class="calibre21"><code class="calibre22">$subQuery = Db::table('think_user')
    -&gt;field('id,name')
    -&gt;where('id','&gt;',10)
    -&gt;fetchSql(true)
    -&gt;select();</code></pre>
<p class="calibre10">生成的subQuery结果为：</p>
<pre class="calibre21"><code class="calibre22">SELECT `id`,`name` FROM `think_user` WHERE `id` &gt; 10 </code></pre>
<h2 id="3%E3%80%81%E4%BD%BF%E7%94%A8%60buildsql%60%E6%9E%84%E9%80%A0%E5%AD%90%E6%9F%A5%E8%AF%A2" class="calibre15">3、使用<code class="calibre7">buildSql</code>构造子查询</h2>
<pre class="calibre21"><code class="calibre22">$subQuery = Db::table('think_user')
    -&gt;field('id,name')
    -&gt;where('id','&gt;',10)
    -&gt;buildSql();</code></pre>
<p class="calibre10">生成的subQuery结果为：</p>
<pre class="calibre21"><code class="calibre22">( SELECT `id`,`name` FROM `think_user` WHERE `id` &gt; 10 )</code></pre>
<p class="calibre10">调用buildSql方法后不会进行实际的查询操作，而只是生成该次查询的SQL语句（为了避免混淆，会在SQL两边加上括号），然后我们直接在后续的查询中直接调用。</p>
<blockquote class="info">
<p class="calibre14">需要注意的是，使用前两种方法需要自行添加‘括号’。</p>
</blockquote>
<p class="calibre10">然后使用子查询构造新的查询：</p>
<pre class="calibre21"><code class="calibre22">Db::table($subQuery.' a')
    -&gt;where('a.name','like','thinkphp')
    -&gt;order('id','desc')
    -&gt;select();</code></pre>
<p class="calibre10">生成的SQL语句为：</p>
<pre class="calibre21"><code class="calibre22">SELECT * FROM ( SELECT `id`,`name` FROM `think_user` WHERE `id` &gt; 10 ) a WHERE a.name LIKE 'thinkphp' ORDER BY `id` desc</code></pre>
<h2 id="4%E3%80%81%E4%BD%BF%E7%94%A8%E9%97%AD%E5%8C%85%E6%9E%84%E9%80%A0%E5%AD%90%E6%9F%A5%E8%AF%A2" class="calibre15">4、使用闭包构造子查询</h2>
<p class="calibre10"><code class="calibre7">IN/NOT IN</code>和<code class="calibre7">EXISTS/NOT EXISTS</code>之类的查询可以直接使用闭包作为子查询，例如：</p>
<pre class="calibre21"><code class="calibre22">Db::table('think_user')
-&gt;where('id','IN',function($query){
    $query-&gt;table('think_profile')-&gt;where('status',1)-&gt;field('id');
})
-&gt;select();</code></pre>
<p class="calibre10">生成的SQL语句是</p>
<pre class="calibre21"><code class="calibre22">SELECT * FROM `think_user` WHERE `id` IN ( SELECT `id` FROM `think_profile` WHERE `status` = 1 )</code></pre>
<pre class="calibre21"><code class="calibre22">Db::table('think_user')
-&gt;where(function($query){
    $query-&gt;table('think_profile')-&gt;where('status',1);
},'exists')
-&gt;find();</code></pre>
<p class="calibre10">生成的SQL语句为</p>
<pre class="calibre21"><code class="calibre22">SELECT * FROM `think_user` WHERE EXISTS ( SELECT * FROM `think_profile` WHERE `status` = 1 ) </code></pre>
</div>
	
</body></html>
