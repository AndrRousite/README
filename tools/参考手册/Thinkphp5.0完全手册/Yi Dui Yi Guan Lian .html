<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-CN" xml:lang="zh-CN">
  <head>
    <title>一对一关联</title>
    <meta content="IE=edge" http-equiv="X-UA-Compatible"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
        <h1 class="book-title" id="calibre_toc_112">一对一关联</h1>
<div class="book-content">
    <h2 id="%E4%B8%80%E5%AF%B9%E4%B8%80%E5%85%B3%E8%81%94" class="calibre15">一对一关联</h2>
<table class="calibre25"><thead class="calibre26"><tr class="calibre27"><th class="calibre28">版本</th>
<th class="calibre28">功能调整</th>
</tr></thead><tbody class="calibre29"><tr class="calibre27"><td class="pcalibre1 calibre30">5.0.5</td>
<td class="calibre32 pcalibre1">增加关联自动写入和删除</td>
</tr><tr class="calibre27"><td class="pcalibre1 calibre31">5.0.4</td>
<td class="calibre33 pcalibre1">增加关联属性绑定到父模型功能</td>
</tr></tbody></table><h3 id="%E5%AE%9A%E4%B9%89" class="calibre17">定义</h3>
<p class="calibre10">定义一对一关联，例如，一个用户都有一个个人资料，我们定义<code class="calibre7">User</code>模型如下：</p>
<pre class="calibre21"><code class="calibre22">namespace app\index\model;

use think\Model;

class User extends Model
{
    public function profile()
    {
        return $this-&gt;hasOne('Profile');
    }
}</code></pre>
<p class="calibre10"><code class="calibre7">hasOne</code>方法的参数包括：</p>
<blockquote class="info">
<h3 id="hasone%28%27%E5%85%B3%E8%81%94%E6%A8%A1%E5%9E%8B%E5%90%8D%27%2C%27%E5%A4%96%E9%94%AE%E5%90%8D%27%2C%27%E4%B8%BB%E9%94%AE%E5%90%8D%27%2C%5B%27%E6%A8%A1%E5%9E%8B%E5%88%AB%E5%90%8D%E5%AE%9A%E4%B9%89%27%5D%2C%27join%E7%B1%BB%E5%9E%8B%27%29%3B" class="calibre17">hasOne('关联模型名','外键名','主键名',['模型别名定义'],'join类型');</h3>
</blockquote>
<p class="calibre10">默认的<code class="calibre7">join</code>类型为<code class="calibre7">INNER</code>。</p>
<p class="calibre10"><code class="calibre7">V5.0.3+</code>版本开始，可以支持为关联模型定义需要查询的字段，例如：</p>
<pre class="calibre21"><code class="calibre22">namespace app\index\model;

use think\Model;

class User extends Model
{
    public function profile()
    {
        return $this-&gt;hasOne('Profile')-&gt;field('id,name,email');
    }
}</code></pre>
<p class="calibre10"><code class="calibre7">5.0.5+</code>版本开始，模型别名定义参数已经废弃。</p>
<h3 id="%E5%85%B3%E8%81%94%E6%9F%A5%E6%89%BE" class="calibre17">关联查找</h3>
<p class="calibre10">定义好关联之后，就可以使用下面的方法获取关联数据：</p>
<pre class="calibre21"><code class="calibre22">$user = User::find(1);
// 输出Profile关联模型的email属性
echo $user-&gt;profile-&gt;email;</code></pre>
<p class="calibre10">默认情况下， 我们使用的是<code class="calibre7">user_id</code> 作为外键关联，如果不是的话则需要在关联定义的时候指定，例如：</p>
<pre class="calibre21"><code class="calibre22">namespace app\index\model;

use think\Model;

class User extends Model 
{
    public function profile()
    {
        return $this-&gt;hasOne('Profile','uid');
    }
}</code></pre>
<blockquote class="danger">
<p class="calibre14">有一点需要注意的是，关联方法的命名规范是驼峰法，而关联属性则一般是小写+下划线的方式，系统在获取的时候会自动转换对应，读取<code class="calibre7">user_profile</code>关联属性则对应的关联方法应该是<code class="calibre7">userProfile</code>。</p>
</blockquote>
<h3 id="%E8%AE%BE%E7%BD%AE%E5%88%AB%E5%90%8D" class="calibre17">设置别名</h3>
<p class="calibre10">如果你的模型名和数据库关键字冲突的话，可以设置别名，例如：</p>
<pre class="calibre21"><code class="calibre22">namespace app\index\model;

use think\Model;

class User extends Model 
{
    public function profile()
    {
        return $this-&gt;hasOne('Profile','uid')-&gt;setAlias(['user'=&gt;'member']);
    }
}</code></pre>
<h3 id="%E5%85%B3%E8%81%94%E6%96%B0%E5%A2%9E" class="calibre17">关联新增</h3>
<pre class="calibre21"><code class="calibre22">$user = User::find(1);
// 如果还没有关联数据 则进行新增
$user-&gt;profile()-&gt;save(['email' =&gt; 'thinkphp']);</code></pre>
<p class="calibre10">系统会自动把当前模型的主键传入profile模型。</p>
<h3 id="%E5%85%B3%E8%81%94%E6%9B%B4%E6%96%B0" class="calibre17">关联更新</h3>
<p class="calibre10">和新增一样使用<code class="calibre7">save</code>方法进行更新关联数据。</p>
<pre class="calibre21"><code class="calibre22">$user = User::find(1);
$user-&gt;profile-&gt;email = 'thinkphp';
$user-&gt;profile-&gt;save();
// 或者
$user-&gt;profile-&gt;save(['email' =&gt; 'thinkphp']);</code></pre>
<h3 id="%E5%AE%9A%E4%B9%89%E7%9B%B8%E5%AF%B9%E7%9A%84%E5%85%B3%E8%81%94" class="calibre17">定义相对的关联</h3>
<p class="calibre10">我们可以在<code class="calibre7">Profile</code>模型中定义一个相对的关联关系，例如：</p>
<pre class="calibre21"><code class="calibre22">namespace app\index\model;

use think\Model;

class Profile extends Model 
{
    public function user()
    {
        return $this-&gt;belongsTo('User');
    }
}</code></pre>
<p class="calibre10"><code class="calibre7">belongsTo</code>的参数包括：</p>
<blockquote class="info">
<h3 id="belongsto%28%27%E5%85%B3%E8%81%94%E6%A8%A1%E5%9E%8B%E5%90%8D%27%2C%27%E5%A4%96%E9%94%AE%E5%90%8D%27%2C%27%E5%85%B3%E8%81%94%E8%A1%A8%E4%B8%BB%E9%94%AE%E5%90%8D%27%2C%5B%27%E6%A8%A1%E5%9E%8B%E5%88%AB%E5%90%8D%E5%AE%9A%E4%B9%89%27%5D%2C%27join%E7%B1%BB%E5%9E%8B%27%29%3B" class="calibre17">belongsTo('关联模型名','外键名','关联表主键名',['模型别名定义'],'join类型');</h3>
</blockquote>
<p class="calibre10">默认的关联外键是<code class="calibre7">user_id</code>，如果不是，需要在第二个参数定义</p>
<pre class="calibre21"><code class="calibre22">namespace app\index\model;

use think\Model;

class Profile extends Model 
{
    public function user()
    {
        return $this-&gt;belongsTo('User','uid');
    }
}</code></pre>
<p class="calibre10">我们就可以根据档案资料来获取用户模型的信息</p>
<pre class="calibre21"><code class="calibre22">$profile = Profile::find(1);
// 输出User关联模型的属性
echo $profile-&gt;user-&gt;account;</code></pre>
<h2 id="%E7%BB%91%E5%AE%9A%E5%B1%9E%E6%80%A7%E5%88%B0%E7%88%B6%E6%A8%A1%E5%9E%8B%EF%BC%88%60v5.0.4%2B%60%EF%BC%89" class="calibre15">绑定属性到父模型（<code class="calibre7">V5.0.4+</code>）</h2>
<p class="calibre10">可以在定义关联的时候使用bind方法绑定属性到父模型，例如：</p>
<pre class="calibre21"><code class="calibre22">namespace app\index\model;

use think\Model;

class User extends Model 
{
    public function profile()
    {
        return $this-&gt;hasOne('Profile','uid')-&gt;bind('nickname,email');
    }
}</code></pre>
<p class="calibre10">或者使用数组的方式指定绑定属性别名</p>
<pre class="calibre21"><code class="calibre22">namespace app\index\model;

use think\Model;

class User extends Model 
{
    public function profile()
    {
        return $this-&gt;hasOne('Profile','uid')-&gt;bind([
                'email',
                'truename'  =&gt; 'nickname',
                'profile_id'  =&gt; 'id',
            ]);
    }
}</code></pre>
<p class="calibre10">然后使用关联预载入查询的时候，可以使用</p>
<pre class="calibre21"><code class="calibre22">$user = User::find(1);
// 输出Profile关联模型的email属性
echo $user-&gt;email;
echo $user-&gt;profile_id;</code></pre>
<p class="calibre10">绑定关联属性不影响原有关联属性的读取，绑定关联模型的属性支持读取器。</p>
<blockquote class="calibre5">
<p class="calibre14">如果不是预载入查询，请使用模型的appendRelationAttr方法追加属性。</p>
</blockquote>
<h2 id="%E5%85%B3%E8%81%94%E8%87%AA%E5%8A%A8%E5%86%99%E5%85%A5%EF%BC%88%60v5.0.5%2B%60%EF%BC%89" class="calibre15">关联自动写入（<code class="calibre7">V5.0.5+</code>）</h2>
<p class="calibre10">我们可以使用<code class="calibre7">together</code>方法更方便的进行关联自动写入操作。</p>
<p class="calibre10">写入</p>
<pre class="calibre21"><code class="calibre22">$blog = new Blog;
$blog-&gt;name = 'thinkphp';
$blog-&gt;title = 'ThinkPHP5关联实例';
$content = new Content;
$content-&gt;data = '实例内容';
$blog-&gt;content = $content;
$blog-&gt;together('content')-&gt;save();</code></pre>
<p class="calibre10">更新</p>
<pre class="calibre21"><code class="calibre22">// 查询
$blog = Blog::get(1);
$blog-&gt;title = '更改标题';
$blog-&gt;content-&gt;data = '更新内容';
// 更新当前模型及关联模型
$blog-&gt;together('content')-&gt;save();</code></pre>
<p class="calibre10">删除</p>
<pre class="calibre21"><code class="calibre22">// 查询
$blog = Blog::get(1);
// 删除当前及关联模型
$blog-&gt;together('content')-&gt;delete();</code></pre>
<blockquote class="calibre5">
<p class="calibre14">如果不想这么麻烦每次调用<code class="calibre7">together</code>方法，也可以直接在模型类中定义<code class="calibre7">relationWrite</code>属性，但必须是数组方式。不过考虑到模型的独立操作的可能性，并不建议。</p>
</blockquote>
</div>
	
</body></html>
