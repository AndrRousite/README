<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-CN" xml:lang="zh-CN">
  <head>
    <title>关联预载入</title>
    <meta content="IE=edge" http-equiv="X-UA-Compatible"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
        <h1 class="book-title" id="calibre_toc_118">关联预载入</h1>
<div class="book-content">
    <h2 id="%E5%85%B3%E8%81%94%E9%A2%84%E8%BD%BD%E5%85%A5" class="calibre15">关联预载入</h2>
<table class="calibre25"><thead class="calibre26"><tr class="calibre27"><th class="calibre28">版本</th>
<th class="calibre28">功能调整</th>
</tr></thead><tbody class="calibre29"><tr class="calibre27"><td class="pcalibre1 calibre30">5.0.5</td>
<td class="calibre32 pcalibre1">增加延迟关联预载入</td>
</tr><tr class="calibre27"><td class="pcalibre1 calibre31">5.0.5</td>
<td class="pcalibre1 calibre31">一对一关联预载入默认采用IN查询方式</td>
</tr><tr class="calibre27"><td class="pcalibre1 calibre31">5.0.4</td>
<td class="calibre33 pcalibre1">一对一关联支持JOIN和IN两种方式预载入查询</td>
</tr></tbody></table><p class="calibre10">关联查询的预查询载入功能，主要解决了<code class="calibre7">N+1</code>次查询的问题，例如下面的查询如果有3个记录，会执行4次查询：</p>
<pre class="calibre21"><code class="calibre22">$list = User::all([1,2,3]);
foreach($list as $user){
    // 获取用户关联的profile模型数据
    dump($user-&gt;profile);
}</code></pre>
<p class="calibre10">如果使用关联预查询功能，对于一对一关联来说，只有一次查询，对于一对多关联的话，就可以变成2次查询，有效提高性能。</p>
<pre class="calibre21"><code class="calibre22">$list = User::with('profile')-&gt;select([1,2,3]);
foreach($list as $user){
    // 获取用户关联的profile模型数据
    dump($user-&gt;profile);
}</code></pre>
<p class="calibre10">支持预载入多个关联，例如：</p>
<pre class="calibre21"><code class="calibre22">$list = User::with('profile,book')-&gt;select([1,2,3]);</code></pre>
<p class="calibre10">也可以支持嵌套预载入，例如：</p>
<pre class="calibre21"><code class="calibre22">$list = User::with('profile.phone')-&gt;select([1,2,3]);
foreach($list as $user){
    // 获取用户关联的phone模型
    dump($user-&gt;profile-&gt;phone);
}</code></pre>
<p class="calibre10">可以在模型的get和all方法中使用预载入，和使用select方法是等效的：</p>
<pre class="calibre21"><code class="calibre22">$list = User::all([1,2,3],'profile,book');</code></pre>
<p class="calibre10">如果要指定属性查询，可以使用：</p>
<pre class="calibre21"><code class="calibre22">$list = User::field('id,name')-&gt;with(['profile'=&gt;function($query){$query-&gt;field('email,phone');}])-&gt;select([1,2,3]);
foreach($list as $user){
    // 获取用户关联的profile模型数据
    dump($user-&gt;profile);
}</code></pre>
<p class="calibre10">关联预载入名称是关联方法名，从<code class="calibre7">V5.0.4+</code>版本开始，支持传入方法名的小写和下划线定义方式，例如如果关联方法名是<code class="calibre7">userProfile</code>和<code class="calibre7">userBook</code>的话：</p>
<pre class="calibre21"><code class="calibre22">$list = User::with('userProfile,userBook')-&gt;select([1,2,3]);</code></pre>
<p class="calibre10">等效于：</p>
<pre class="calibre21"><code class="calibre22">$list = User::with('user_profile,user_book')-&gt;select([1,2,3]);</code></pre>
<p class="calibre10"><code class="calibre7">V5.0.4+</code>版本开始一对一关联预载入支持两种方式：<code class="calibre7">JOIN</code>方式（一次查询）和<code class="calibre7">IN</code>方式（两次查询），如果要使用<code class="calibre7">IN</code>方式关联预载入，在关联定义方法中添加</p>
<pre class="calibre21"><code class="calibre22">namespace app\index\model;

use think\Model;

class User extends Model
{
    public function profile()
    {
        // 设置预载入查询方式为IN方式
        return $this-&gt;hasOne('Profile')-&gt;setEagerlyType(1);
    }
}</code></pre>
<p class="calibre10"><code class="calibre7">V5.0.5+</code>版本开始，默认使用IN查询方式，如果需要改为JOIN查询方式，使用</p>
<pre class="calibre21"><code class="calibre22">        // 设置预载入查询方式为JOIN方式
        return $this-&gt;hasOne('Profile')-&gt;setEagerlyType(0);</code></pre>
<h3 id="%E5%BB%B6%E8%BF%9F%E9%A2%84%E8%BD%BD%E5%85%A5%EF%BC%88%60v5.0.5%2B%60%EF%BC%89" class="calibre17">延迟预载入（<code class="calibre7">V5.0.5+</code>）</h3>
<p class="calibre10">有些情况下，需要根据查询出来的数据来决定是否需要使用关联预载入，当然关联查询本身就能解决这个问题，因为关联查询是惰性的，不过用预载入的理由也很明显，性能具有优势。</p>
<p class="calibre10">延迟预载入仅针对多个数据的查询，因为单个数据的查询用延迟预载入和关联惰性查询没有任何区别，所以不需要使用延迟预载入。</p>
<p class="calibre10">如果你的数据集查询返回的是数据集对象，可以使用调用数据集对象的<code class="calibre7">load</code>实现延迟预载入：</p>
<pre class="calibre21"><code class="calibre22">// 查询数据集
$list = User::all([1,2,3]);
// 延迟预载入
$list-&gt;load('cards');
foreach($list as $user){
    // 获取用户关联的card模型数据
    dump($user-&gt;cards);
}</code></pre>
<p class="calibre10">如果你的数据集查询返回的是数组，系统提供了一个<code class="calibre7">load_relation</code>助手函数可以完成同样的功能。</p>
<pre class="calibre21"><code class="calibre22">// 查询数据集
$list = User::all([1,2,3]);
// 延迟预载入
$list = load_relation($list,'cards');
foreach($list as $user){
    // 获取用户关联的card模型数据
    dump($user-&gt;cards);
}</code></pre>
</div>
	
</body></html>
