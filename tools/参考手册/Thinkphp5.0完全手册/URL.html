<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-CN" xml:lang="zh-CN">
  <head>
    <title>URL重写</title>
    <meta content="IE=edge" http-equiv="X-UA-Compatible"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
        <h1 class="book-title" id="calibre_toc_218">URL重写</h1>
<div class="book-content">
    <p class="calibre10">可以通过URL重写隐藏应用的入口文件<code class="calibre7">index.php</code>,下面是相关服务器的配置参考：</p>
<h2 id="%5B+apache+%5D" class="calibre15">[ Apache ]</h2>
<ol class="calibre18"><li class="calibre20">httpd.conf配置文件中加载了mod_rewrite.so模块</li>
<li class="calibre20">AllowOverride None 将None改为 All</li>
<li class="calibre20">把下面的内容保存为.htaccess文件放到应用入口文件的同级目录下</li>
</ol><pre class="calibre21"><code class="calibre22">&lt;IfModule mod_rewrite.c&gt;
Options +FollowSymlinks -Multiviews
RewriteEngine on

RewriteCond %{REQUEST_FILENAME} !-d
RewriteCond %{REQUEST_FILENAME} !-f
RewriteRule ^(.*)$ index.php?/$1 [QSA,PT,L]
&lt;/IfModule&gt;</code></pre>
<h2 id="%5B+iis+%5D" class="calibre15">[ IIS ]</h2>
<p class="calibre10">如果你的服务器环境支持ISAPI_Rewrite的话，可以配置httpd.ini文件，添加下面的内容：</p>
<pre class="calibre21"><code class="calibre22">RewriteRule (.*)$ /index\.php\?s=$1 [I]</code></pre>
<p class="calibre10">在IIS的高版本下面可以配置web.Config，在中间添加rewrite节点：</p>
<pre class="calibre21"><code class="calibre22">&lt;rewrite&gt;
 &lt;rules&gt;
 &lt;rule name="OrgPage" stopProcessing="true"&gt;
 &lt;match url="^(.*)$" /&gt;
 &lt;conditions logicalGrouping="MatchAll"&gt;
 &lt;add input="{HTTP_HOST}" pattern="^(.*)$" /&gt;
 &lt;add input="{REQUEST_FILENAME}" matchType="IsFile" negate="true" /&gt;
 &lt;add input="{REQUEST_FILENAME}" matchType="IsDirectory" negate="true" /&gt;
 &lt;/conditions&gt;
 &lt;action type="Rewrite" url="index.php/{R:1}" /&gt;
 &lt;/rule&gt;
 &lt;/rules&gt;
 &lt;/rewrite&gt;</code></pre>
<h2 id="%5B+nginx+%5D" class="calibre15">[ Nginx ]</h2>
<p class="calibre10">在Nginx低版本中，是不支持PATHINFO的，但是可以通过在Nginx.conf中配置转发规则实现：</p>
<pre class="calibre21"><code class="calibre22">  location / { // …..省略部分代码
   if (!-e $request_filename) {
   rewrite  ^(.*)$  /index.php?s=/$1  last;
   break;
    }
 }</code></pre>
<blockquote class="calibre5">
<p class="calibre14">其实内部是转发到了ThinkPHP提供的兼容URL，利用这种方式，可以解决其他不支持PATHINFO的WEB服务器环境。</p>
</blockquote>
<p class="calibre10">如果你的应用安装在二级目录，<code class="calibre7">Nginx</code>的伪静态方法设置如下，其中<code class="calibre7">youdomain</code>是所在的目录名称。</p>
<pre class="calibre21"><code class="calibre22">location /youdomain/ {
    if (!-e $request_filename){
        rewrite  ^/youdomain/(.*)$  /youdomain/index.php?s=/$1  last;
    }
}</code></pre>
<p class="calibre10">原来的访问URL：</p>
<pre class="calibre21"><code class="calibre22">http://serverName/index.php/模块/控制器/操作/[参数名/参数值...]</code></pre>
<p class="calibre10">设置后，我们可以采用下面的方式访问：</p>
<pre class="calibre21"><code class="calibre22">http://serverName/模块/控制器/操作/[参数名/参数值...]</code></pre>
<p class="calibre10">如果你没有修改服务器的权限，可以在index.php入口文件做修改，这不是正确的做法，并且不一定成功，视服务器而定，只是在框架执行前补全$_SERVER['PATH_INFO']参数</p>
<pre class="calibre21"><code class="calibre22">$_SERVER['PATH_INFO'] = $_SERVER['REQUEST_URI' ];</code></pre>
</div>
	
</body></html>
