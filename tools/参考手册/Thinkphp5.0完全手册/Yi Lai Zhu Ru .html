<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-CN" xml:lang="zh-CN">
  <head>
    <title>依赖注入</title>
    <meta content="IE=edge" http-equiv="X-UA-Compatible"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
        <h1 class="book-title" id="calibre_toc_66">依赖注入</h1>
<div class="book-content">
    <p class="calibre10">ThinkPHP的依赖注入（也称之为控制反转）是一种较为轻量的实现，无需任何的配置，并且主要针对访问控制器进行依赖注入。可以在控制器的构造函数或者操作方法（指访问请求的方法）中类型声明任何（对象类型）依赖，这些依赖会被自动解析并注入到控制器实例或方法中。</p>
<h2 id="%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5%E8%AF%B7%E6%B1%82%E5%AF%B9%E8%B1%A1" class="calibre15">自动注入请求对象</h2>
<h3 id="%E6%9E%B6%E6%9E%84%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5" class="calibre17">架构方法注入</h3>
<p class="calibre10">在控制器的架构方法中会自动注入当前请求对象，例如：</p>
<pre class="calibre21"><code class="calibre22">namespace app\index\controller;

use think\Request;

class Index
{
    protected $request;

    public function __construct(Request $request)
    {
        $this-&gt;request = $request;
    }

    public function hello()
    {
        return 'Hello,' . $this-&gt;request-&gt;param('name') . '！';
    }

}</code></pre>
<h3 id="%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5" class="calibre17">操作方法注入</h3>
<p class="calibre10">控制器的操作方法中如果需要调用请求对象<code class="calibre7">Request</code>的话，可以在方法中定义<code class="calibre7">Request</code>类型的参数，并且参数顺序无关，例如：</p>
<pre class="calibre21"><code class="calibre22">namespace app\index\controller;

use think\Request;

class Index
{

    public function hello(Request $request)
    {
        return 'Hello,' . $request-&gt;param('name') . '！';
    }

}</code></pre>
<p class="calibre10">访问URL地址的时候 无需传入<code class="calibre7">request</code>参数，系统会自动注入当前的<code class="calibre7">Request</code>对象实例到该参数。</p>
<p class="calibre10">如果继承了系统的<code class="calibre7">Controller</code>类的话，也可以直接调用<code class="calibre7">request</code>属性，例如：</p>
<pre class="calibre21"><code class="calibre22">&lt;?php
namespace app\index\controller;

use think\Controller;

class Index extends Controller
{

    public function hello()
    {
        return 'Hello,'.$this-&gt;request-&gt;param('name');
    }

}</code></pre>
<h2 id="%E5%85%B6%E5%AE%83%E5%AF%B9%E8%B1%A1%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5%EF%BC%88%60v5.0.1%60%EF%BC%89" class="calibre15">其它对象自动注入（<code class="calibre7">V5.0.1</code>）</h2>
<p class="calibre10">从<code class="calibre7">5.0.1</code>版本开始，控制器的架构方法和操作方法支持任意对象的自动注入。</p>
<h3 id="%E6%9E%B6%E6%9E%84%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5-1" class="calibre17">架构方法注入</h3>
<pre class="calibre21"><code class="calibre22">namespace app\index\controller;

use app\index\model\User;
use think\Request;

class Index
{
    protected $request;
    protected $user;

    public function __construct(Request $request, User $user)
    {
        $this-&gt;request = $request;
        $this-&gt;user = $user;
    }

}</code></pre>
<blockquote class="calibre5">
<p class="calibre14">对于已经进行了绑定（属性注入）的对象，即可自动完成依赖注入，如果没有进行对象绑定的话，会自动实例化一个新的对象示例传入（如果类定义有<code class="calibre7">instance</code>方法，则会自动调用<code class="calibre7">instance</code>方法进行实例化）。</p>
</blockquote>
<p class="calibre10">架构方法的依赖注入不影响其它类型的参数绑定。</p>
<h3 id="%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5-1" class="calibre17">操作方法注入</h3>
<p class="calibre10">我们把<code class="calibre7">User</code>模型绑定到当前请求对象：</p>
<pre class="calibre21"><code class="calibre22">Request::instance()-&gt;bind('user', \app\index\model\User::get(1));</code></pre>
<p class="calibre10">然后就可以在操作方法中进行对象参数的自动注入，代码：</p>
<pre class="calibre21"><code class="calibre22">&lt;?php
namespace app\index\controller;

use app\index\model\User;
use think\Controller;

class Index extends Controller
{

    public function hello(User $user)
    {
        return 'Hello,'.$user-&gt;name;
    }

}</code></pre>
<p class="calibre10">如果没有事先在Request对象中进行对象绑定的话，调用<code class="calibre7">hello</code>方法的时候<code class="calibre7">user</code>参数会自动实例化，相当于完成了下面的绑定操作：</p>
<pre class="calibre21"><code class="calibre22">Request::instance()-&gt;bind('user', new \app\index\model\User);</code></pre>
<blockquote class="calibre5">
<p class="calibre14">对象自动注入不影响原来的参数绑定。</p>
</blockquote>
<h2 id="invoke%E6%96%B9%E6%B3%95%E8%87%AA%E5%8A%A8%E8%B0%83%E7%94%A8%EF%BC%88%60v5.0.2%60%EF%BC%89" class="calibre15">invoke方法自动调用（<code class="calibre7">v5.0.2</code>）</h2>
<p class="calibre10">5.0.2版本开始，如果依赖注入的类有定义一个可调用的静态<code class="calibre7">invoke</code>方法，则会自动调用invoke方法完成依赖注入的自动实例化。</p>
<p class="calibre10"><code class="calibre7">invoke</code>方法的参数是当前请求对象实例，例如：</p>
<pre class="calibre21"><code class="calibre22">namespace app\index\model;

use think\Model;
class User extends Model
{
    public static function invoke(Request $request)
    {
        $id = $request-&gt;param('id');
        return User::get($id);
    }
}</code></pre>
</div>
	
</body></html>
