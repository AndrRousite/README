<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-CN" xml:lang="zh-CN">
  <head>
    <title>模板布局</title>
    <meta content="IE=edge" http-equiv="X-UA-Compatible"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
        <h1 class="book-title" id="calibre_toc_139">模板布局</h1>
<div class="book-content">
    <p class="calibre10">ThinkPHP的模板引擎内置了布局模板功能支持，可以方便的实现模板布局以及布局嵌套功能。</p>
<p class="calibre10">有三种布局模板的支持方式：</p>
<h2 id="%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F" class="calibre15">第一种方式：全局配置方式</h2>
<p class="calibre10">这种方式仅需在项目配置文件中添加相关的布局模板配置，就可以简单实现模板布局功能，比较适用于全站使用相同布局的情况，需要配置开启layout_on 参数（默认不开启），并且设置布局入口文件名layout_name（默认为layout）。</p>
<pre class="calibre21"><code class="calibre22">'template'  =&gt;  [
    'layout_on'     =&gt;  true,
    'layout_name'   =&gt;  'layout',
]</code></pre>
<p class="calibre10">开启<code class="calibre7">layout_on</code>后，我们的模板渲染流程就有所变化，例如：</p>
<pre class="calibre21"><code class="calibre22">namespace app\index\controller;

use think\Controller;

Class User extends Controller
{
     public function add() 
     {
         return $this-&gt;fetch('add');
     }
}</code></pre>
<p class="calibre10">在不开启<code class="calibre7">layout_on</code>布局模板之前，会直接渲染 <code class="calibre7">application/index/view/user/add.html</code> 模板文件,开启之后，首先会渲染<code class="calibre7">application/index/view/layout.html</code> 模板，布局模板的写法和其他模板的写法类似，本身也可以支持所有的模板标签以及包含文件，区别在于有一个特定的输出替换变量<code class="calibre7">{__CONTENT__}</code>，例如，下面是一个典型的layout.html模板的写法：</p>
<pre class="calibre21"><code class="calibre22">{include file="public/header" /}
 {__CONTENT__}
{include file="public/footer" /}</code></pre>
<p class="calibre10">读取layout模板之后，会再解析<code class="calibre7">user/add.html</code> 模板文件，并把解析后的内容替换到layout布局模板文件的{<strong class="calibre12">CONTENT</strong>} 特定字符串。</p>
<p class="calibre10">当然可以通过设置来改变这个特定的替换字符串，例如：</p>
<pre class="calibre21"><code class="calibre22">'template'  =&gt;  [
    'layout_on'     =&gt;  true,
    'layout_name'   =&gt;  'layout',
    'layout_item'   =&gt;  '{__REPLACE__}'
]</code></pre>
<blockquote class="calibre5">
<p class="calibre14">一个布局模板同时只能有一个特定替换字符串。</p>
</blockquote>
<p class="calibre10">采用这种布局方式的情况下，一旦user/add.html 模板文件或者layout.html布局模板文件发生修改，都会导致模板重新编译。</p>
<p class="calibre10">如果需要指定其他位置的布局模板，可以使用：</p>
<pre class="calibre21"><code class="calibre22">'template'  =&gt;  [
    'layout_on'     =&gt;  true,
    'layout_name'   =&gt;  'layout/layoutname',
    'layout_item'   =&gt;  '{__REPLACE__}'
]</code></pre>
<p class="calibre10">就表示采用<code class="calibre7">application/index/view/layout/layoutname.html</code>作为布局模板。</p>
<p class="calibre10">如果某些页面不需要使用布局模板功能，可以在模板文件开头加上 <code class="calibre7">{__NOLAYOUT__}</code> 字符串。</p>
<p class="calibre10">如果上面的user/add.html 模板文件里面包含有<code class="calibre7">{__NOLAYOUT__}</code>，则即使当前开启布局模板，也不会进行布局模板解析。</p>
<h2 id="%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A%E6%A8%A1%E6%9D%BF%E6%A0%87%E7%AD%BE%E6%96%B9%E5%BC%8F" class="calibre15">第二种方式：模板标签方式</h2>
<p class="calibre10">这种布局模板不需要在配置文件中设置任何参数，也不需要开启<code class="calibre7">layout_on</code>，直接在模板文件中指定布局模板即可，相关的布局模板调整也在模板中进行。</p>
<p class="calibre10">以前面的输出模板为例，这种方式的入口还是在user/add.html 模板，但是我们可以修改下add模板文件的内容，在头部增加下面的布局标签（记得首先关闭前面的<code class="calibre7">layout_on</code>设置，否则可能出现布局循环）：</p>
<pre class="calibre21"><code class="calibre22">{layout name="layout" /}</code></pre>
<p class="calibre10">表示当前模板文件需要使用<code class="calibre7">layout.html</code> 布局模板文件，而布局模板文件的写法和上面第一种方式是一样的。当渲染<code class="calibre7">user/add.html</code> 模板文件的时候，如果读取到layout标签，则会把当前模板的解析内容替换到layout布局模板的{<strong class="calibre12">CONTENT</strong>} 特定字符串。</p>
<p class="calibre10">一个模板文件中只能使用一个布局模板，如果模板文件中没有使用任何layout标签则表示当前模板不使用任何布局。</p>
<p class="calibre10">如果需要使用其他的布局模板，可以改变layout的name属性，例如：</p>
<pre class="calibre21"><code class="calibre22">{layout name="newlayout" /}</code></pre>
<p class="calibre10">还可以在layout标签里面指定要替换的特定字符串：</p>
<pre class="calibre21"><code class="calibre22">{layout name="Layout/newlayout" replace="[__REPLACE__]" /}</code></pre>
<h2 id="%E7%AC%AC%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A%E4%BD%BF%E7%94%A8layout%E6%8E%A7%E5%88%B6%E6%A8%A1%E6%9D%BF%E5%B8%83%E5%B1%80" class="calibre15">第三种方式：使用layout控制模板布局</h2>
<p class="calibre10">使用内置的layout方法可以更灵活的在程序中控制模板输出的布局功能，尤其适用于局部需要布局或者关闭布局的情况，这种方式也不需要在配置文件中开启layout_on。例如：</p>
<pre class="calibre21"><code class="calibre22">namespace app\index\controller;

use think\Controller;

class User extends Controller
{
     public function add() 
     {
         $this-&gt;view-&gt;engine-&gt;layout(true);
         return $this-&gt;fetch('add');
     }
}</code></pre>
<p class="calibre10">表示当前的模板输出启用了布局模板，并且采用默认的layout布局模板。</p>
<p class="calibre10">如果当前输出需要使用不同的布局模板，可以动态的指定布局模板名称，例如：</p>
<pre class="calibre21"><code class="calibre22">namespace app\index\controller;

use think\Controller;

class User extends Controller
{
     public function add() 
     {
         $this-&gt;view-&gt;engine-&gt;layout('Layout/newlayout');
         return $this-&gt;display('add');
     }
}</code></pre>
<p class="calibre10">或者使用layout方法动态关闭当前模板的布局功能（这种用法可以配合第一种布局方式，例如全局配置已经开启了布局，可以在某个页面单独关闭）：</p>
<pre class="calibre21"><code class="calibre22">namespace app\index\controller;

use think\Controller;

class User extends Controller
{
     public function add() 
     {
        // 临时关闭当前模板的布局功能
         $this-&gt;view-&gt;engine-&gt;layout(false); 
         return $this-&gt;display('add');
     }
}</code></pre>
<blockquote class="calibre5">
<p class="calibre14">三种模板布局方式中，第一种和第三种是在程序中配置实现模板布局，第二种方式则是单纯通过模板标签在模板中使用布局。具体选择什么方式，需要根据项目的实际情况来了。</p>
</blockquote>
</div>
	
</body></html>
