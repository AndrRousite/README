<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-CN" xml:lang="zh-CN">
  <head>
    <title>批量注册</title>
    <meta content="IE=edge" http-equiv="X-UA-Compatible"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
        <h1 class="book-title" id="calibre_toc_28">批量注册</h1>
<div class="book-content">
    <p class="calibre10">批量注册路由规则可以使用两种方式，包括方法注册和路由配置定义。</p>
<h2 id="%E6%89%B9%E9%87%8F%E6%B3%A8%E5%86%8C" class="calibre15">批量注册</h2>
<p class="calibre10">如果不希望一个个注册，可以使用批量注册，规则如下：</p>
<pre class="calibre21"><code class="calibre22">Route::rule([
'路由规则1'=&gt;'路由地址和参数',
'路由规则2'=&gt;['路由地址和参数','匹配参数（数组）','变量规则（数组）']
...
],'','请求类型','匹配参数（数组）','变量规则');</code></pre>
<p class="calibre10">如果在外面和规则里面同时传入了匹配参数和变量规则的话，路由规则定义里面的最终生效，但请求类型参数以最外层决定，例如：</p>
<pre class="calibre21"><code class="calibre22">Route::rule([
    'new/:id'  =&gt;  'News/read',
    'blog/:id' =&gt;  ['Blog/update',['ext'=&gt;'shtml'],['id'=&gt;'\d{4}']],
    ...
],'','GET',['ext'=&gt;'html'],['id'=&gt;'\d+']);</code></pre>
<p class="calibre10">以上的路由注册，最终<code class="calibre7">blog/:id</code>只会在匹配shtml后缀的访问请求，id变量的规则则是 <code class="calibre7">\d{4}</code>。</p>
<blockquote class="calibre5">
<p class="calibre14">如果不同的请求类型的路由规则是一样的，为了避免数组索引冲突的问题，请使用单独的请求方法定义路由。</p>
</blockquote>
<p class="calibre10">同样，我们也可以使用其他几个注册方法进行批量注册。</p>
<pre class="calibre21"><code class="calibre22">// 批量注册GET路由
Route::get([
    'new/:id'  =&gt;  'News/read',
    'blog/:id' =&gt;  ['Blog/edit',[],['id'=&gt;'\d+']]
    ...
]);
// 效果等同于
Route::rule([
    'new/:id'  =&gt;  'News/read',
    'blog/:id' =&gt;  ['Blog/edit',[],['id'=&gt;'\d+']]
    ...
],'','GET');</code></pre>
<h2 id="%E5%AE%9A%E4%B9%89%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6" class="calibre15">定义路由配置文件</h2>
<p class="calibre10">除了支持动态注册，也可以直接在应用目录下面的<code class="calibre7">route.php</code> 的最后通过返回数组的方式直接定义路由规则，内容示例如下：</p>
<pre class="calibre21"><code class="calibre22">return [
    'new/:id'   =&gt; 'News/read',
    'blog/:id'   =&gt; ['Blog/update',['method' =&gt; 'post|put'], ['id' =&gt; '\d+']],
];</code></pre>
<p class="calibre10">路由配置文件定义的路由规则效果和使用<code class="calibre7">any</code>注册路由规则一样。</p>
<p class="calibre10">路由动态注册和配置定义的方式可以共存，例如：</p>
<pre class="calibre21"><code class="calibre22">use think\Route;

Route::rule('hello/:name','index/index/hello');

return [
    'new/:id'   =&gt; 'News/read',
    'blog/:id'   =&gt; ['Blog/update',['method' =&gt; 'post|put'], ['id' =&gt; '\d+']],
];</code></pre>
<p class="calibre10">默认情况下，只会加载一个路由配置文件<code class="calibre7">route.php</code>，如果你需要定义多个路由文件，可以修改<code class="calibre7">route_config_file</code>配置参数，例如：</p>
<pre class="calibre21"><code class="calibre22">// 定义路由配置文件（数组）
'route_config_file' =&gt;  ['route', 'route1', 'route2'],</code></pre>
<p class="calibre10">如果存在相同的路由规则，一样可以参考前面的批量注册方式进行定义。</p>
<blockquote class="calibre5">
<p class="calibre14">由于检测机制问题，动态注册的性能比路由配置要高一些，尤其是多种请求类型混合定义的时候。</p>
</blockquote>
</div>
	
</body></html>
