<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-CN" xml:lang="zh-CN">
  <head>
    <title>分层控制器</title>
    <meta content="IE=edge" http-equiv="X-UA-Compatible"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
        <h1 class="book-title" id="calibre_toc_51">分层控制器</h1>
<div class="book-content">
    <h2 id="%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%99%A8" class="calibre15">访问控制器</h2>
<p class="calibre10">ThinkPHP引入了分层控制器的概念，通过URL访问的控制器为访问控制器层（Controller）或者主控制器，访问控制器是由<code class="calibre7">\think\App</code>类负责调用和实例化的，无需手动实例化。</p>
<p class="calibre10">URL解析和路由后，会把当前的URL地址解析到 <strong class="calibre12">[ 模块/控制器/操作 ]</strong>，其实也就是执行某个控制器类的某个操作方法，下面是一个示例：</p>
<pre class="calibre21"><code class="calibre22">namespace app\index\controller;

class Blog 
{
    public function index()
    {
        return 'index';
    }

    public function add()
    {
        return 'add';
    }

    public function edit($id)
    {
        return 'edit:'.$id;
    }
}</code></pre>
<p class="calibre10">当前定义的主控制器位于index模块下面，所以当访问不同的URL地址的页面输出如下：</p>
<pre class="calibre21"><code class="calibre22">http://serverName/index/blog/index // 输出 index
http://serverName/index/blog/add     // 输出 add
http://serverName/index/blog/edit/id/5 // 输出 edit:5
</code></pre>
<blockquote class="calibre5">
<p class="calibre14">新版的控制器可以不需要继承任何基类，当然，你可以定义一个公共的控制器基础类来被继承，也可以通过控制器扩展来完成不同的功能（例如Restful实现）。</p>
</blockquote>
<p class="calibre10">如果不经过路由访问的话，URL中的控制器名会首先强制转为小写，然后再解析为驼峰法实例化该控制器。</p>
<h2 id="%E5%88%86%E5%B1%82%E6%8E%A7%E5%88%B6%E5%99%A8" class="calibre15">分层控制器</h2>
<p class="calibre10">除了访问控制器外，我们还可以定义其他分层控制器类，这些分层控制器是不能够被URL访问直接调用到的，只能在访问控制器、模型类的内部，或者视图模板文件中进行调用。</p>
<p class="calibre10">例如，我们定义Blog事件控制器如下：</p>
<pre class="calibre21"><code class="calibre22">namespace app\index\event;

class Blog 
{
    public function insert()
    {
        return 'insert';
    }

    public function update($id)
    {
        return 'update:'.$id;
    }

    public function delete($id)
    {
        return 'delete:'.$id;
    }
}</code></pre>
<p class="calibre10">定义完成后，就可以用下面的方式实例化并调用方法了：</p>
<pre class="calibre21"><code class="calibre22">$event = \think\Loader::controller('Blog', 'event');
echo $event-&gt;update(5); // 输出 update:5
echo $event-&gt;delete(5); // 输出 delete:5
</code></pre>
<p class="calibre10">为了方便调用，系统提供了controller助手函数直接实例化多层控制器，例如：</p>
<pre class="calibre21"><code class="calibre22">$event = controller('Blog', 'event');
echo $event-&gt;update(5); // 输出 update:5
echo $event-&gt;delete(5); // 输出 delete:5</code></pre>
<p class="calibre10">支持跨模块调用，例如：</p>
<pre class="calibre21"><code class="calibre22">$event = controller('Admin/Blog', 'event');
echo $event-&gt;update(5); // 输出 update:5</code></pre>
<p class="calibre10">表示实例化Admin模块的Blog控制器类，并执行update方法。</p>
<p class="calibre10">除了实例化分层控制器外，还可以直接调用分层控制器类的某个方法，例如：</p>
<pre class="calibre21"><code class="calibre22">echo \think\Loader::action('Blog/update', ['id' =&gt; 5], 'event'); // 输出 update:5
</code></pre>
<p class="calibre10">也可以使用助手函数<code class="calibre7">action</code>实现相同的功能：</p>
<pre class="calibre21"><code class="calibre22">echo action('Blog/update', ['id' =&gt; 5], 'event'); // 输出 update:5
</code></pre>
<p class="calibre10">利用分层控制器的机制，我们可以用来实现<code class="calibre7">Widget</code>（其实就是在模板中调用分层控制器），例如：<br class="calibre16"/>
定义<code class="calibre7">index\widget\Blog</code>控制器类如下：</p>
<pre class="calibre21"><code class="calibre22">namespace app\index\widget;

class Blog {
    public function header()
    {
        return 'header';
    }

    public function left()
    {
        return 'left';
    }

    public function menu($name)
    {
        return 'menu:'.$name;
    }
}</code></pre>
<p class="calibre10">我们在模板文件中就可以直接调用<code class="calibre7">app\index\widget\Blog</code>分层控制器了，<br class="calibre16"/>
使用助手函数<code class="calibre7">action</code></p>
<pre class="calibre21"><code class="calibre22">{:action('Blog/header', '', 'widget')}
{:action('Blog/menu', ['name' =&gt; 'think'], 'widget')}</code></pre>
<p class="calibre10">框架还提供了<code class="calibre7">widget</code>函数用于简化<code class="calibre7">Widget</code>控制器的调用，<br class="calibre16"/>
可以直接使用助手函数<code class="calibre7">widget</code></p>
<pre class="calibre21"><code class="calibre22">{:widget('Blog/header')}
{:widget('Blog/menu', ['name' =&gt; 'think'])}</code></pre>
</div>
	
</body></html>
