<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-CN" xml:lang="zh-CN">
  <head>
    <title>路由定义</title>
    <meta content="IE=edge" http-equiv="X-UA-Compatible"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
        <h1 class="book-title" id="calibre_toc_27">路由定义</h1>
<div class="book-content">
    <h2 id="%E6%B3%A8%E5%86%8C%E8%B7%AF%E7%94%B1%E8%A7%84%E5%88%99" class="calibre15">注册路由规则</h2>
<p class="calibre10">路由注册可以采用方法动态单个和批量注册，也可以直接定义路由定义文件的方式进行集中注册。</p>
<h3 id="%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C" class="calibre17">动态注册</h3>
<p class="calibre10">路由定义采用<code class="calibre7">\think\Route</code>类的<code class="calibre7">rule</code>方法注册，通常是在应用的路由配置文件<code class="calibre7">application/route.php</code>进行注册，格式是：</p>
<blockquote class="info">
<h4 id="route%3A%3Arule%28%27%E8%B7%AF%E7%94%B1%E8%A1%A8%E8%BE%BE%E5%BC%8F%27%2C%27%E8%B7%AF%E7%94%B1%E5%9C%B0%E5%9D%80%27%2C%27%E8%AF%B7%E6%B1%82%E7%B1%BB%E5%9E%8B%27%2C%27%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0%EF%BC%88%E6%95%B0%E7%BB%84%EF%BC%89%27%2C%27%E5%8F%98%E9%87%8F%E8%A7%84%E5%88%99%EF%BC%88%E6%95%B0%E7%BB%84%EF%BC%89%27%29%3B" class="calibre6">Route::rule('路由表达式','路由地址','请求类型','路由参数（数组）','变量规则（数组）');</h4>
</blockquote>
<p class="calibre10">例如注册如下路由规则：</p>
<pre class="calibre21"><code class="calibre22">use think\Route;
// 注册路由到index模块的News控制器的read操作
Route::rule('new/:id','index/News/read');</code></pre>
<p class="calibre10">我们访问：</p>
<pre class="calibre21"><code class="calibre22">http://serverName/new/5</code></pre>
<blockquote class="calibre5">
<p class="calibre14">ThinkPHP5.0的路由规则定义是从根目录开始，而不是基于模块名的。</p>
</blockquote>
<p class="calibre10">会自动路由到：</p>
<pre class="calibre21"><code class="calibre22">http://serverName/index/news/read/id/5</code></pre>
<p class="calibre10">并且原来的访问地址会自动失效。</p>
<p class="calibre10">路由表达式（第一个参数）支持定义命名标识，例如：</p>
<pre class="calibre21"><code class="calibre22">// 定义new路由命名标识
Route::rule(['new','new/:id'],'index/News/read');</code></pre>
<blockquote class="calibre5">
<p class="calibre14">注意，路由命名标识必须唯一，定义后可以用于URL的快速生成。</p>
</blockquote>
<p class="calibre10">可以在rule方法中指定请求类型，不指定的话默认为任何请求类型，例如：</p>
<pre class="calibre21"><code class="calibre22">Route::rule('new/:id','News/update','POST');</code></pre>
<p class="calibre10">表示定义的路由规则在POST请求下才有效。</p>
<table class="calibre25"><thead class="calibre26"><tr class="calibre27"><th class="calibre28">请求类型包括：</th>
<th class="calibre28">类型</th>
<th class="calibre28">描述</th>
</tr></thead><tbody class="calibre29"><tr class="calibre27"><td class="pcalibre1 calibre30">GET</td>
<td class="calibre32 pcalibre1">GET请求</td>
</tr><tr class="calibre27"><td class="pcalibre1 calibre31">POST</td>
<td class="pcalibre1 calibre31">POST请求</td>
</tr><tr class="calibre27"><td class="pcalibre1 calibre31">PUT</td>
<td class="pcalibre1 calibre31">PUT请求</td>
</tr><tr class="calibre27"><td class="pcalibre1 calibre31">DELETE</td>
<td class="pcalibre1 calibre31">DELETE请求</td>
</tr><tr class="calibre27"><td class="pcalibre1 calibre31">*</td>
<td class="calibre33 pcalibre1">任何请求类型</td>
</tr></tbody></table><blockquote class="calibre5">
<p class="calibre14">注意：请求类型参数必须大写。</p>
</blockquote>
<p class="calibre10">系统提供了为不同的请求类型定义路由规则的简化方法，例如：</p>
<pre class="calibre21"><code class="calibre22">Route::get('new/:id','News/read'); // 定义GET请求路由规则
Route::post('new/:id','News/update'); // 定义POST请求路由规则
Route::put('new/:id','News/update'); // 定义PUT请求路由规则
Route::delete('new/:id','News/delete'); // 定义DELETE请求路由规则
Route::any('new/:id','News/read'); // 所有请求都支持的路由规则</code></pre>
<p class="calibre10">如果要定义get和post请求支持的路由规则，也可以用：</p>
<pre class="calibre21"><code class="calibre22">Route::rule('new/:id','News/read','GET|POST');</code></pre>
<p class="calibre10">我们也可以批量注册路由规则，例如：</p>
<pre class="calibre21"><code class="calibre22">Route::rule(['new/:id'=&gt;'News/read','blog/:name'=&gt;'Blog/detail']);
Route::get(['new/:id'=&gt;'News/read','blog/:name'=&gt;'Blog/detail']);
Route::post(['new/:id'=&gt;'News/update','blog/:name'=&gt;'Blog/detail']);</code></pre>
<p class="calibre10">注册多个路由规则后，系统会依次遍历注册过的满足请求类型的路由规则，一旦匹配到正确的路由规则后则开始调用控制器的操作方法，后续规则就不再检测。</p>
<h2 id="%E8%B7%AF%E7%94%B1%E8%A1%A8%E8%BE%BE%E5%BC%8F" class="calibre15">路由表达式</h2>
<p class="calibre10">路由表达式统一使字符串定义，采用规则定义的方式。</p>
<blockquote class="danger">
<p class="calibre14">正则路由定义功能已经废除，改由变量规则定义完成。</p>
</blockquote>
<h3 id="%E8%A7%84%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F" class="calibre17">规则表达式</h3>
<p class="calibre10">规则表达式通常包含静态地址和动态地址，或者两种地址的结合，例如下面都属于有效的规则表达式：</p>
<pre class="calibre21"><code class="calibre22">'/' =&gt; 'index', // 首页访问路由
'my'        =&gt;  'Member/myinfo', // 静态地址路由
'blog/:id'  =&gt;  'Blog/read', // 静态地址和动态地址结合
'new/:year/:month/:day'=&gt;'News/read', // 静态地址和动态地址结合
':user/:blog_id'=&gt;'Blog/read',// 全动态地址</code></pre>
<p class="calibre10">规则表达式的定义以<code class="calibre7">/</code>为参数分割符（无论你的PATH_INFO分隔符设置是什么，请确保在定义路由规则表达式的时候统一使用<code class="calibre7">/</code>进行URL参数分割）。</p>
<p class="calibre10">每个参数中以“:”开头的参数都表示动态变量，并且会自动绑定到操作方法的对应参数。</p>
<h3 id="%E5%8F%AF%E9%80%89%E5%AE%9A%E4%B9%89" class="calibre17">可选定义</h3>
<p class="calibre10">支持对路由参数的可选定义，例如：</p>
<pre class="calibre21"><code class="calibre22">'blog/:year/[:month]'=&gt;'Blog/archive',</code></pre>
<p class="calibre10"><code class="calibre7">[:month]</code>变量用<code class="calibre7">[ ]</code>包含起来后就表示该变量是路由匹配的可选变量。</p>
<p class="calibre10">以上定义路由规则后，下面的URL访问地址都可以被正确的路由匹配：</p>
<pre class="calibre21"><code class="calibre22">http://serverName/index.php/blog/2015
http://serverName/index.php/blog/2015/12</code></pre>
<p class="calibre10">采用可选变量定义后，之前需要定义两个或者多个路由规则才能处理的情况可以合并为一个路由规则。</p>
<blockquote class="calibre5">
<p class="calibre14">可选参数只能放到路由规则的最后，如果在中间使用了可选参数的话，后面的变量都会变成可选参数。</p>
</blockquote>
<h3 id="%E5%AE%8C%E5%85%A8%E5%8C%B9%E9%85%8D" class="calibre17">完全匹配</h3>
<p class="calibre10">规则匹配检测的时候只是对URL从头开始匹配，只要URL地址包含了定义的路由规则就会匹配成功，如果希望完全匹配，可以在路由表达式最后使用<code class="calibre7">$</code>符号，例如：</p>
<pre class="calibre21"><code class="calibre22">'new/:cate$'=&gt; 'News/category',</code></pre>
<pre class="calibre21"><code class="calibre22">http://serverName/index.php/new/info</code></pre>
<p class="calibre10">会匹配成功,而</p>
<pre class="calibre21"><code class="calibre22">http://serverName/index.php/new/info/2 </code></pre>
<p class="calibre10">则不会匹配成功。</p>
<p class="calibre10">如果是采用</p>
<pre class="calibre21"><code class="calibre22">'new/:cate'=&gt; 'News/category',</code></pre>
<p class="calibre10">方式定义的话，则两种方式的URL访问都可以匹配成功。</p>
<p class="calibre10">如果你希望所有的路由定义都是完全匹配的话，可以直接配置</p>
<pre class="calibre21"><code class="calibre22">// 开启路由定义的全局完全匹配
'route_complete_match'  =&gt;  true,</code></pre>
<p class="calibre10">当开启全局完全匹配的时候，如果个别路由不需要使用完整匹配，可以添加路由参数覆盖定义：</p>
<pre class="calibre21"><code class="calibre22">Route::rule('new/:id','News/read','GET|POST',['complete_match' =&gt; false]);</code></pre>
<h2 id="%E9%A2%9D%E5%A4%96%E5%8F%82%E6%95%B0" class="calibre15">额外参数</h2>
<p class="calibre10">在路由跳转的时候支持额外传入参数对（额外参数指的是不在URL里面的参数，隐式传入需要的操作中，有时候能够起到一定的安全防护作用，后面我们会提到）。例如：</p>
<pre class="calibre21"><code class="calibre22">'blog/:id'=&gt;'blog/read?status=1&amp;app_id=5',</code></pre>
<p class="calibre10">上面的路由规则定义中额外参数的传值方式都是等效的。<code class="calibre7">status</code>和<code class="calibre7">app_id</code>参数都是URL里面不存在的，属于隐式传值，当然并不一定需要用到，只是在需要的时候可以使用。</p>
</div>
	
</body></html>
