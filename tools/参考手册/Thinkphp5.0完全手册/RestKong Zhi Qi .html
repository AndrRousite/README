<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-CN" xml:lang="zh-CN">
  <head>
    <title>Rest控制器</title>
    <meta content="IE=edge" http-equiv="X-UA-Compatible"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
        <h1 class="book-title" id="calibre_toc_52">Rest控制器</h1>
<div class="book-content">
    <h2 id="rest%E6%8E%A7%E5%88%B6%E5%99%A8" class="calibre15">Rest控制器</h2>
<blockquote class="danger">
<p class="calibre14">新版不再推荐使用Rest控制器，建议用资源控制器替代。下一个大版本即将废弃。</p>
</blockquote>
<p class="calibre10">如果需要让你的控制器支持RESTful的话，可以使用Rest控制器，在定义访问控制器的时候直接继承<code class="calibre7">think\controller\Rest</code>即可，例如：</p>
<pre class="calibre21"><code class="calibre22">namespace app\index\controller;

use think\controller\Rest;

class Blog extends Rest
{
}</code></pre>
<p class="calibre10">配合示例需要，我们首先在应用配置文件中添加：</p>
<pre class="calibre21"><code class="calibre22">// URL伪静态后缀
'url_html_suffix'        =&gt; 'html|xml|json|jsonp',</code></pre>
<h3 id="restful%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89" class="calibre17">RESTFul方法定义</h3>
<p class="calibre10"><code class="calibre7">RESTFul</code>方法和标准模式的操作方法定义主要区别在于，需要对请求类型和资源类型进行判断，大多数情况下，通过路由定义可以把操作方法绑定到某个请求类型和资源类型。如果你没有定义路由的话，需要自己在操作方法里面添加判断代码，示例：</p>
<pre class="calibre21"><code class="calibre22">&lt;?php

namespace app\index\controller;

use think\controller\Rest;

class Blog extends Rest
{
    public function rest()
    {
        switch ($this-&gt;method){
        case 'get': // get请求处理代码
            if ($this-&gt;type == 'html'){
            } elseif ($this-&gt;type == 'xml'){
            }
            break;
        case 'put': // put请求处理代码
            break;
        case 'post': // post请求处理代码
            break;
        }
    }
}</code></pre>
<p class="calibre10">在Rest操作方法中，可以使用<code class="calibre7">$this-&gt;type</code>获取当前访问的资源类型，用<code class="calibre7">$this-&gt;method</code>获取当前的请求类型。</p>
<h3 id="restful+%E8%BE%93%E5%87%BA" class="calibre17">RESTFul 输出</h3>
<h4 id="%E4%BD%BF%E7%94%A8rest%E7%B1%BB%E6%8F%90%E4%BE%9B%E7%9A%84+response+%E6%96%B9%E6%B3%95" class="calibre6">使用Rest类提供的 response 方法</h4>
<pre class="calibre21"><code class="calibre22">$this-&gt;response($data, 'json', 200);</code></pre>
<h4 id="%E4%BD%BF%E7%94%A8%60think%5Cresponse%60%E7%B1%BB" class="calibre6">使用<code class="calibre7">think\Response</code>类</h4>
<pre class="calibre21"><code class="calibre22">Response::create($data, 'json')-&gt;code(200);</code></pre>
<h4 id="%E4%BD%BF%E7%94%A8%E5%8A%A9%E6%89%8B%E5%87%BD%E6%95%B0" class="calibre6">使用助手函数</h4>
<pre class="calibre21"><code class="calibre22">json($data, 200);</code></pre>
<p class="calibre10">$data为需要输出的数据，第二个参数为输出数据的http状态码<br class="calibre16"/>
方法会自动对$data数据进行输出类型编码，目前支持的包括xml,json,jsonp,html等编码格式输出，例如：</p>
<pre class="calibre21"><code class="calibre22">// 输出 json 格式数据
json($data, 200);
// 输出 jsonp 格式数据
jsonp($data, 200);
// 输出 xml 格式数据
xml($data, 200);</code></pre>
<table class="calibre25"><thead class="calibre26"><tr class="calibre27"><th class="calibre28">除了普通方式定义Restful操作方法外，系统还支持另外一种自动调用方式，就是根据当前请求类型和资源类型自动调用相关操作方法。系统的自动调用规则是：</th>
<th class="calibre28">定义规范</th>
<th class="calibre28">说明</th>
</tr></thead><tbody class="calibre29"><tr class="calibre27"><td class="pcalibre1 calibre30">操作名_提交类型_资源后缀</td>
<td class="calibre32 pcalibre1">标准的Restful方法定义，例如 read_get_pdf</td>
</tr><tr class="calibre27"><td class="pcalibre1 calibre31">操作名_资源后缀</td>
<td class="pcalibre1 calibre31">当前提交类型和restDefaultMethod相同的时候，例如read_pdf</td>
</tr><tr class="calibre27"><td class="pcalibre1 calibre31">操作名_提交类型</td>
<td class="calibre33 pcalibre1">当前资源后缀和restDefaultType相同的时候，例如read_post</td>
</tr></tbody></table><p class="calibre10">这种方式的rest方法定义采用了空操作机制，所以要使用这种方式的前提就是不能为当前操作定义方法，如果检测到相关的restful方法则不再检查后面的方法规范，例如我们定义了InfoController如下：</p>
<pre class="calibre21"><code class="calibre22">namespace app\index\controller;

use think\controller\Rest;

class Info extends Rest
{
    public function read_get_xml($id)
    {
        // 输出id为1的Info的XML数据
    }

    public function read_xml($id)
    {
        // 输出id为1的Info的XML数据
    }

    public function read_json($id)
    {
        // 输出id为1的Info的json数据
    }
}</code></pre>
<p class="calibre10">如果我们访问的URL是：</p>
<pre class="calibre21"><code class="calibre22">http://serverName/index/info/read/id/1.xml
</code></pre>
<p class="calibre10">假设我们没有定义路由，这样访问的是Info模块的read操作，那么上面的请求会调用Info类的 read_get_xml方法，而不是read_xml方法，但是如果访问的URL是：</p>
<pre class="calibre21"><code class="calibre22">http://serverName/index/info/read/id/1.json
</code></pre>
<p class="calibre10">那么则会调用read_json方法。</p>
</div>
	
</body></html>
